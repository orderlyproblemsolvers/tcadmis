import{computed as e,toValue as a,getCurrentInstance as t,onServerPrefetch as r,ref as n,shallowRef as o,toRef as s,nextTick as i,unref as c}from"vue";import{f as u,k as l,l as d}from"./server.mjs";const f={trailing:!0};function debounce(e,a=25,t={}){if(t={...f,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let r,n,o,s,i=[];const applyFn=(a,r)=>(o=async function(e,a,t){return await e.apply(a,t)}(e,a,r),o.finally(()=>{if(o=null,t.trailing&&s&&!n){const e=applyFn(a,s);return s=null,e}}),o),debounced=function(...e){return t.trailing&&(s=e),o||new Promise(o=>{const c=!n&&t.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const a=t.leading?r:applyFn(this,e);s=null;for(const e of i)e(a);i=[]},a),c?(r=applyFn(this,e),o(r)):i.push(o)})},_clearTimeout=e=>{e&&(clearTimeout(e),n=null)};return debounced.isPending=()=>!!n,debounced.cancel=()=>{_clearTimeout(n),i=[],s=null},debounced.flush=()=>{if(_clearTimeout(n),!s||o)return;const e=s;return s=null,applyFn(this,e)},debounced}function useAsyncData(...f){const y="string"==typeof f[f.length-1]?f.pop():void 0;(function(e,a){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof a)return!1;return!0})(f[0],f[1])&&f.unshift(y);let[p,v,_={}]=f;const b=e(()=>a(p));if("string"!=typeof b.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof v)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const D=u();function createInitialFetch(){const a={cause:"initial",dedupe:_.dedupe};return D._asyncData[b.value]?._init||(a.cachedData=_.getCachedData(b.value,D,{cause:"initial"}),D._asyncData[b.value]=function(a,t,r,u,l){a.payload._errors[t]??=void 0;const f=u.getCachedData!==getDefaultCachedData,y=r,p=u.deep?n:o,v=void 0!==l,_=a.hook("app:data:refresh",async e=>{e&&!e.includes(t)||await b.execute({cause:"refresh:hook"})}),b={data:p(v?l:u.default()),pending:e(()=>"pending"===b.status.value),error:s(a.payload._errors,t),status:o("idle"),execute:(...e)=>{const[r,n]=e,o=r&&void 0===n&&"object"==typeof r?r:{};if(a._asyncDataPromises[t]&&"defer"===(o.dedupe??u.dedupe))return a._asyncDataPromises[t];{const e="cachedData"in o?o.cachedData:u.getCachedData(t,a,{cause:o.cause??"refresh:manual"});if(void 0!==e)return a.payload.data[t]=b.data.value=e,b.error.value=void 0,b.status.value="success",Promise.resolve(e)}b._abortController&&b._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),b._abortController=new AbortController,b.status.value="pending";const s=new AbortController,i=new Promise((e,t)=>{try{const r=o.timeout??u.timeout,n=function(e,a,t){const r=e.filter(e=>!!e);if("number"==typeof t&&t>=0){const e=AbortSignal.timeout?.(t);e&&r.push(e)}if(AbortSignal.any)return AbortSignal.any(r);const n=new AbortController;for(const e of r)if(e.aborted){const a=e.reason??new DOMException("Aborted","AbortError");try{n.abort(a)}catch{n.abort()}return n.signal}const onAbort=()=>{const e=r.find(e=>e.aborted),a=e?.reason??new DOMException("Aborted","AbortError");try{n.abort(a)}catch{n.abort()}};for(const e of r)e.addEventListener?.("abort",onAbort,{once:!0,signal:a});return n.signal}([b._abortController?.signal,o?.signal],s.signal,r);if(n.aborted){const e=n.reason;return void t(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))}return n.addEventListener("abort",()=>{const e=n.reason;t(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))},{once:!0,signal:s.signal}),Promise.resolve(y(a,{signal:n})).then(e,t)}catch(e){t(e)}}).then(async e=>{let r=e;u.transform&&(r=await u.transform(e)),u.pick&&(r=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(r,u.pick)),a.payload.data[t]=r,b.data.value=r,b.error.value=void 0,b.status.value="success"}).catch(e=>a._asyncDataPromises[t]&&a._asyncDataPromises[t]!==i||b._abortController?.signal.aborted?a._asyncDataPromises[t]:"undefined"!=typeof DOMException&&e instanceof DOMException&&"AbortError"===e.name?(b.status.value="idle",a._asyncDataPromises[t]):(b.error.value=d(e),b.data.value=c(u.default()),void(b.status.value="error"))).finally(()=>{s.abort(),delete a._asyncDataPromises[t]});return a._asyncDataPromises[t]=i,a._asyncDataPromises[t]},_execute:debounce((...e)=>b.execute(...e),0,{leading:!0}),_default:u.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{_(),a._asyncData[t]?._init&&(a._asyncData[t]._init=!1),f||i(()=>{a._asyncData[t]?._init||(clearNuxtDataByKey(a,t),b.execute=()=>Promise.resolve())})}};return b}(D,b.value,v,_,a.cachedData)),()=>D._asyncData[b.value].execute(a)}_.server??=!0,_.default??=getDefault,_.getCachedData??=getDefaultCachedData,_.lazy??=!1,_.immediate??=!0,_.deep??=l.deep,_.dedupe??="cancel",_._functionName,D._asyncData[b.value];const m=createInitialFetch();D._asyncData[b.value]._deps++;if(!1!==_.server&&D.payload.serverRendered&&_.immediate){const e=m();t()?r(()=>e):D.hook("app:created",async()=>{await e})}const h={data:writableComputedRef(()=>D._asyncData[b.value]?.data),pending:writableComputedRef(()=>D._asyncData[b.value]?.pending),status:writableComputedRef(()=>D._asyncData[b.value]?.status),error:writableComputedRef(()=>D._asyncData[b.value]?.error),refresh:(...e)=>{if(!D._asyncData[b.value]?._init){return createInitialFetch()()}return D._asyncData[b.value].execute(...e)},execute:(...e)=>h.refresh(...e),clear:()=>{const e=D._asyncData[b.value];if(e?._abortController)try{e._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{e._abortController=void 0}clearNuxtDataByKey(D,b.value)}},g=Promise.resolve(D._asyncDataPromises[b.value]).then(()=>h);return Object.assign(g,h),g}function writableComputedRef(a){return e({get:()=>a()?.value,set(e){const t=a();t&&(t.value=e)}})}function clearNuxtDataByKey(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=void 0),e._asyncData[a]&&(e._asyncData[a].data.value=c(e._asyncData[a]._default()),e._asyncData[a].error.value=void 0,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]=void 0)}const getDefault=()=>{},getDefaultCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;export{useAsyncData as u};
//# sourceMappingURL=asyncData-DWeUa_vf.mjs.map
